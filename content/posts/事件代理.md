---
date: "2025-08-18T22:31:12+08:00"
draft: false
title: "js-事件代理"
tags: ["深入浅出", "事件代理"]
categories: ["js"]
---

## 事件代理

把元素响应事件（click,keydown） 的函数委托到另一个元素

    事件流会经历的三个阶段   捕获阶段- 目标阶段- 冒泡阶段

事件委托在`冒泡阶段`完成

把一个或者一组元素委托到它的父层或者外层元素上， 真正绑定的是外层元素，非目标函数

```js
<input type="button" name="" id="btn" value="添加" />
<ul id="ul1">
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
    <li>item 4</li>
</ul>
使用事件委托

const oBtn = document.getElementById("btn");
const oUl = document.getElementById("ul1");
const num = 4;

//事件委托，添加的子元素也有事件
oUl.onclick = function (ev) {
    ev = ev || window.event;
    const target = ev.target || ev.srcElement;
    if (target.nodeName.toLowerCase() == 'li') {
        console.log('the content is: ', target.innerHTML);
    }

};

//添加新节点
oBtn.onclick = function () {
    num++;
    const oLi = document.createElement('li');
    oLi.innerHTML = `item ${num}`;
    oUl.appendChild(oLi);
};
```

## 小结

适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress

事件委托存在两大优点：

- 减少整个页面所需的内存，提升整体性能
- 动态绑定，减少重复工作

但是使用事件委托也是存在局限性：

- focus、blur 这些事件没有事件冒泡机制，所以无法进行委托绑定事件

- mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的

- 如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件
