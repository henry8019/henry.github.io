---
date: "2025-10-28T22:31:12+08:00"
draft: false
title: "js-事件循环"
tags: ["深入浅出", "事件循环", "宏任务与微任务", "async与 await"]
categories: ["js"]
---

## 一、事件循环

javascript 是单线程语言，同一时间只能做一件事情

在 javascript 中，所有任务可以分为

- 同步任务：立即执行的任务，一般直接进入到主线程中执行
- 异步任务：异步执行的任务，例如 ajax 请求，setTimeout 定时函数

## 宏任务与微任务

`过去`把消息队列分为微任务队列和宏任务队列，这种说法已经无法满足现在复杂的浏览器环境，取而代之的是另一种灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务只能在同一个队列，不同类型的任务可以在不同的队列。不同的任务队列有不同的优先级。在一次事件循环中，由浏览器自行决定从哪个队列中取出任务执行（交互队列优先级高于延时队列），但必须有一个最高优先级的微任务队列，其中的任务优先调度

eg：

```js
onsole.log(1);

setTimeout(() => {
	console.log(2);
}, 0);

new Promise((resolve, reject) => {
	console.log("new Promise");
	resolve();
}).then(() => {
	console.log("then");
});

console.log(3);
```

result:1,newpromise,3,2,then

### 微任务：

主函数执行结束，宏任务结束之前
常见的微任务有：

Promise.then

MutaionObserver

Object.observe（已废弃；Proxy 对象替代）

process.nextTick（Node.js）

### 宏任务

常见的宏任务有：

script (可以理解为外层同步代码)

setTimeout/setInterval

UI rendering/UI 事件

postMessage、MessageChannel

setImmediate、I/O（Node.js）

## async 与 await

async 声明一个异步方法，await 等待异步方法执行

async:

```js
function f() {
	return Promise.resolve("TEST");
}

// asyncF is equivalent to f!
async function asyncF() {
	return "TEST";
}
```

==
await:

```js
async function f() {
	// 等同于
	// return 123
	return await 123;
}
f().then((v) => console.log(v)); // 123
```

## 总流程分析

```js
async function async1() {
	console.log("async1 start");
	await async2();
	console.log("async1 end");
}
async function async2() {
	console.log("async2");
}
console.log("script start");
setTimeout(function () {
	console.log("settimeout");
});
async1();
new Promise(function (resolve) {
	console.log("promise1");
	resolve();
}).then(function () {
	console.log("promise2");
});
console.log("script end");
```

1 执行整段代码，遇到 console.log('script start') 直接打印结果，输出 script start

2 遇到定时器了，它是宏任务，先放着不执行

3 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到 await 怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码

4 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行

5 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await 下面的代码，打印 async1 end

6 继续执行下一个微任务，即执行 then 的回调，打印 promise2

上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout
`结果是` ：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout
